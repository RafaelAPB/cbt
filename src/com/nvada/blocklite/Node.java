package com.nvada.blocklite;
import java.sql.Timestamp;
import java.util.LinkedList;
import java.util.List;

import com.nvada.blocklite.config.Constants;
import com.nvada.blocklite.data.DataCell;
import com.nvada.blocklite.data.Transaction;
import com.nvada.blocklite.log.Logger;
import com.nvada.blocklite.proof.ProofStack;

import java.util.ArrayList;
import java.util.HashMap;

public class Node{

	private boolean type; //type true for fast nodes and false for lazy nodes
	private int id;
	private String uID;
	private float currOwned;
	private Timestamp creationTime;
	
	private boolean isCrash;

	//For the next set of events to executed by the node
	Timestamp nextTxnTime;
	Timestamp nextBlockTime;

	List<DataCell> allCells = new ArrayList<DataCell>(); 

	LinkedList<Block> blockIncludePending = new LinkedList<Block>();
	int numBlockIncludedPending = 0;

	//Varialbes to store information about longest chain received so far
	Block probParentBlock;

	int numSentTxn = 0;

	//Connection Details
	LinkedList<Node> connectedNode = new LinkedList<Node>();
	
	int numConnection = 0;
	int numCreatedBlock = 0; //Number of block generated by this node so far

	//Tree to store all the blocks heard by the Node so far
	HashMap<String, Block> blockMap = new HashMap<String, Block>();

	//HashMap to store all the transactions forwarded by the node.
	HashMap<String, Boolean> forwardedMessage = new HashMap<String, Boolean>();

	//Default constructor
	Node(int id, boolean type, Timestamp creationTime, Block genesisBlock){
		this.id = id;
		this.uID = "Node_"+id;
		this.type = type;
		this.creationTime = creationTime;
		this.currOwned = 50;
		this.probParentBlock = genesisBlock;
		blockMap.put(genesisBlock.getBlockID(),genesisBlock);
	}

	//function to gerate block at a particular timestamp
	public Block generateBlock(Block parentBlock, Timestamp creationTime, int mainDiff, int subDiff){
		this.nextBlockTime = creationTime;
		this.probParentBlock = parentBlock;
		this.calculateWeight();
		
		//ProofWork proof = new ProofWork(mainDiff, subDiff);
		ProofStack proof = new ProofStack(mainDiff, subDiff);
		return new Block(proof, creationTime, uID, parentBlock, null);
	}

	//Code to add a block in the node's block chain
	public boolean addBlock(Block newBlock){
		// long startMining= System.currentTimeMillis();
		// System.out.println("\nstart Mining at: " + startMining);
		newBlock.mineBlock();
		// System.out.println("Mining time: " + (System.currentTimeMillis() - startMining));		
	
		//check if all txns in the block valid according to me
		boolean valid = true;
		ArrayList<DataCell> tmpTxns = newBlock.getCells();
		HashMap<String, Float> weightMap = new HashMap<String, Float>();
		
		for(int i=0;i<tmpTxns.size();i++){
			if(false == checkValid(weightMap, tmpTxns.get(i))) {
				valid = false;
				break;
			}
		}
		//end of check
		
		String parentBlockID = newBlock.getParentBlockID();
		String currentBlockID = newBlock.getBlockID();
		String creatorID = newBlock.getCreatorID();
		
		if(blockMap.containsKey(parentBlockID) && valid) {
			blockMap.put(currentBlockID, newBlock);
			if(!blockMap.get(parentBlockID).checkChild(currentBlockID)){
				blockMap.get(parentBlockID).putChild(currentBlockID);
				if(this.uID.equals(creatorID)){
					numCreatedBlock++;
				}
				return true;
			}
		}else{
			//block can turn valid lateron
			if(!this.blockIncludePending.contains(newBlock)){
				this.blockIncludePending.add(newBlock);
				Logger.getInstance().logBlockMine("block valid = " + valid + ", add to pending");
			} else {
				Logger.getInstance().logBlockMine("block valid = " + valid);
			}
		}
		return false;
	}
	
	//adds pending blocks to the block chain
	public void addPendingBlocks(){ 
		int num_new = 1;
		while(num_new>0){
			num_new = 0;
			for(int i=0;i<this.blockIncludePending.size();i++) { // Note: pending list for blocks needs to be stored and loaded
				if(this.addBlock(this.blockIncludePending.get(i))){ // Note: assume now, it is loaded from DB
					num_new++;
				}
			}
		}
	}
	
	// adding pending transaction to the new block
	public void addPendingTx2NewBlock(Block newBlock) {
		//mining fee transaction 
		//Transaction mfee = new Transaction(getUID()+"_mining_fee", Constants.GOD_ID, getUID(), 50, new Timestamp(System.currentTimeMillis()));

		//newBlock.addTxn(mfee); // adding mining fee at the current transaction in array list of current block
		//System.out.println("new block minined successfully, 50 coins rewards at time: " +System.currentTimeMillis());
		
		//change block to include transactions
		Block parent = probParentBlock;
		HashMap<String, Float> weightMap = new HashMap<String, Float>();
		
		boolean alreadyIncluded = false;
		DataCell tmpTxn = null;
		
		for(int i=0;i<allCells.size(); i++) { // verify all Txns
			alreadyIncluded = false;
			tmpTxn = allCells.get(i);
			
			if(false == checkValid(weightMap, tmpTxn)) {
				continue;
			}
			
			parent = probParentBlock;
			while(parent!=null){ // controlling double spending
				if(parent.cells.contains(tmpTxn)){
					alreadyIncluded = true;
					break;
				}
				parent = parent.getParentBlock();
			}
			if(!alreadyIncluded) {
				//long beginAdd = System.currentTimeMillis();
				newBlock.addTxn(tmpTxn); 
				//System.out.println("add Txns time interval: " + String.valueOf(System.currentTimeMillis() - beginAdd));
			}
		}
	}
	
	//function to generate a transaction
	Transaction generateTxn(String receiverID, float txnAmount, Timestamp txnTime){
		String txnID = uID + "_" + numSentTxn;
		Transaction newTxn = new Transaction(txnID, uID, receiverID, txnAmount, txnTime);
		return newTxn;
	}
	
	//function to add a new transaction to a node
	boolean addDataCell(DataCell newCell) {
		
		if(!allCells.contains(newCell)) {
			
			if(newCell.getSenderID().equals(this.uID)) {
				if(newCell.getWeight() > currOwned){
					return false;
				} else {
					numSentTxn++;
				}
			}
			
			allCells.add(newCell);
		}
		
		return true;
	}
	
	public boolean checkValid(HashMap<String, Float> weightMap, DataCell tmpTxn) {
		String senderID = tmpTxn.getSenderID();
		
		if(senderID.equals(Constants.GOD_ID) || tmpTxn.getWeight() == 0) {
			return true;
		}
		
		float totalWeight = 0;
		
		if(weightMap.containsKey(senderID)) {
			totalWeight = weightMap.get(senderID);
		} else {
			totalWeight = calculatWeight(senderID);
			weightMap.put(senderID, totalWeight);
		}
		
		if(totalWeight >= tmpTxn.getWeight()) {
			totalWeight = totalWeight-tmpTxn.getWeight();
			weightMap.put(senderID, totalWeight);
			return true;
		}
	
		return false;
	}

	//check if txn is valid or not (Proof of work is conducted here)
	public boolean checkValid(DataCell t){
		String senderID = t.getSenderID();
		
		if(senderID.equals(Constants.GOD_ID) || t.getWeight() == 0) {
			return true;
		}
		
		return (calculatWeight(senderID) >= t.getWeight());
	}
	
	//calculate weight of cell I own in the longest block chain
	public double calculateWeight(){
		float btc = calculatWeight(this.uID);
		this.currOwned = btc;
		return btc;
	}
	
	private float calculatWeight(String ownerId) {
		float weight = 0;
		
		//Note: get parent block's transaction list for a given block from DB
		Block blk_iter = this.probParentBlock;
		
		while(blk_iter!=null) {			
			if(blk_iter.cells != null && blk_iter.cells.size() > 0) {
				
				for(DataCell cell: blk_iter.cells) {
					if(cell.getWeight() == 0) {
						continue;
					}
					
					if(ownerId.equals(cell.getSenderID())) {
						// deducting transaction amount if current node is sender
						weight -= cell.getWeight();
					}else if(ownerId.equals(cell.getReceiverID())){
						//incrementing transaction amount if current node is receiver
						weight += cell.getWeight();
					}
				}
			}

			blk_iter = blk_iter.getParentBlock();
		}
		
		return weight;
	}

	//Add Node to connected Nodes
	void connect2Node(Node newNode){
		connectedNode.add(newNode);
		numConnection++;
	}
	
	public int getId(){
		return id;
	}

	//userID return
	public String getUID(){
		return uID;
	}

	//type return
	public boolean getType(){
		return type;
	}

	//creationTime return
	public Timestamp getCreationTime(){
		return creationTime;
	}

	//userID return
	public float getCurrOwned(){
		return currOwned;
	}

	//to update the currently owned value
	public void updateCurrOwned(float newAmount){
		this.currOwned = newAmount;
	}

	//overwritting toString method for Node
	public String toString(){
		return "ID: "+this.uID+" type: "+ (this.type?"fast":"lazy") + " Creation time: "+this.creationTime  + " Balance: "+this.currOwned;
	}

	public Node connectedNodeAt(int index){
		if(index >= numConnection){
			return null;
		}
		else{
			return connectedNode.get(index);
		}		
	}

	//Function to check given a blockID or transactionID whether that is already being forwarded or not
	public boolean checkForwarded(String newID){
		return (forwardedMessage.containsKey(newID));		
	}

	public void addForwarded(String newID){
		this.forwardedMessage.put(newID, true);
	}

	public boolean isCrash() {
		return isCrash;
	}

	public void setCrash(boolean isCrash) {
		this.isCrash = isCrash;
	}
	
	public void crash() {
		
		if(false == this.isCrash) {
			this.isCrash = true;
			Logger.getInstance().logNode(this.uID + " crashed!");
		}
		
	}
	
	public void recover() {
		this.isCrash = false;
	}
}